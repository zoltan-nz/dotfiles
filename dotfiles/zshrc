# IMPORTANT!
# Copy ./dotfiles/zshrc.local.template to ~/.zshrc.local and setup your environment variables

# Import your local profile file
[ -s ~/.zshrc.local ] && source ~/.zshrc.local
DOTFILES=${DOTFILES:-$HOME/projects/dotfiles}

export PATH="/Applications/Docker.app/Contents/Resources/bin:$HOME/.bin:$HOME/.brew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:$PATH"

### ===  ZSH SETTINGS ===

export ZSH=$DOTFILES/submodules/zsh/oh-my-zsh
export ZSH_CUSTOM=$DOTFILES/submodules/zsh/custom

ZSH_THEME=${LOCAL_ZSH_THEME:-agnoster}
HYPHEN_INSENSITIVE="true"
DISABLE_AUTO_UPDATE="true"
COMPLETION_WAITING_DOTS="true"
DISABLE_UNTRACKED_FILES_DIRTY="true"
ZSH_AUTOSUGGEST_STRATEGY="match_prev_cmd"

# Temporary plugins: docker go kubectl java mvn
plugins=(git zsh-completions zsh-autosuggestions fasd tmux zsh completion npm yarn)

# Comments for plugins
# zsh-completions - https://github.com/zsh-users/zsh-completions
# zsh-autosuggestions - git://github.com/zsh-users/zsh-autosuggestions
# httpie - https://github.com/jkbrzt/httpie
# fasd - https://github.com/clvv/fasd

source $ZSH/oh-my-zsh.sh

# zsh-syntax-highlighting - https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md
source $ZSH_CUSTOM/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# https://github.com/zsh-users/zsh-history-substring-search
source $ZSH_CUSTOM/plugins/zsh-history-substring-search/zsh-history-substring-search.zsh

### === ALIAS ===

# This must have for a proper color support in old gnome-terminal!!! And don't change global TERM!!!
alias tmux="TERM=xterm-256color tmux attach || tmux new"

alias zshconfig="vim $DOTFILES/dotfiles/zshrc"
alias vimconfig="vim $DOTFILES/dotfiles/vimrc"

# On Mac, please `brew install coreutils`
if [ "$(uname)" = "Darwin" ]; then
  alias ls="gls --color -ah --group-directories-first --sort=extension"
  alias lsa="gls --color -lah --group-directories-first --sort=extension"
elif [ "$(expr substr $(uname -s) 1 5)" = "Linux" ]; then
  # On Linux
  alias ls="ls --color -h --group-directories-first"
fi

# Vim with v; f installed by fasd
alias v="f -e vim"
alias gv="fasd -e mvim"

alias c="clear"
alias x="exit"

# alias markd="(pid=\`cat /tmp/grip.pid\`;kill $pid;grip > /dev/null 2>1  &;echo $! > /tmp/grip.pid;open http://localhost:6419)"

# Load local alias file if exists
[ -s "$HOME/.alias" ] && source ~/.alias

### === HOMEBREW ===

# Install homebrew in your home folder ~/.brew
# brew install zsh-completions
fpath=(/Users/$USER/.brew/share/zsh-completions $fpath)

# export HOMEBREW_CASK_OPTS="--caskroom=$HOME/.brew/caskroom --binarydir=$HOME/.bin"
export HOMEBREW_GITHUB_API_TOKEN=$HOMEBREW_GITHUB_API_TOKEN

### === RBENV ===

# git clone https://github.com/rbenv/rbenv.git ~/.rbenv
# git clone https://github.com/sstephenson/ruby-build ~/.rbenv/plugins/ruby-build
export RBENV_ROOT="${HOME}/.rbenv"
if [ -d "${RBENV_ROOT}" ]; then
  export PATH="${RBENV_ROOT}/bin:${PATH}"
  eval "$(rbenv init -)"
fi

### === NVM ===

# git clone https://github.com/creationix/nvm ~/.nvm
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh" # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# Add yarn bin

export PATH=$PATH:$HOME/.yarn/bin

# Automatically switch to the supported node version whenever entering a directory that contains an .nvmrc file
# place this after nvm initialization!
# autoload -U add-zsh-hook
load-nvmrc() {
  local node_version="$(nvm version)"
  local nvmrc_path="$(nvm_find_nvmrc)"

  if [ -n "$nvmrc_path" ]; then
    local nvmrc_node_version=$(nvm version "$(cat "${nvmrc_path}")")

    if [ "$nvmrc_node_version" = "N/A" ]; then
      nvm install
    elif [ "$nvmrc_node_version" != "$node_version" ]; then
      nvm use
    fi
  elif [ "$node_version" != "$(nvm version default)" ]; then
    echo "Reverting to nvm default version"
    nvm use default
  fi
}

# add-zsh-hook chpwd load-nvmrc
load-nvmrc

### === PYENV ===

# curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash
export PYENV_ROOT="${HOME}/.pyenv"
if [ -d "${PYENV_ROOT}" ]; then
  export PATH="${PYENV_ROOT}/bin:$PATH"
  eval "$(pyenv init -)"
  eval "$(pyenv virtualenv-init -)"
fi

### === GOLANG ===

export GOPATH=$HOME/projects/go
export PATH=$PATH:$HOME/.brew/opt/go/libexec/bin:$GOPATH/bin

### === BASH hack ===

# Binding Alt+left and Alt+right jumping words
# bindkey -e
# if [ "$TERM" =~ "^xterm" ]; then
#   bindkey '^[^[[D' backward-word
#   bindkey '^[^[[C' forward-word
# elif [ "$TERM" =~ "^screen" ]; then
#   bindkey '^[[1;3D' backward-word
#   bindkey '^[[1;3C' forward-word
# fi

# infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\177/' > ~/.$TERM.ti
# tic ~/.$TERM.ti

### === JENV ===
# Check steps here: https://stackoverflow.com/questions/26252591/mac-os-x-and-multiple-java-versions/47699905#47699905
# brew install jenv
# brew tap caskroom/versions
# brew cask search java

export JENV_ROOT="${HOME}/.jenv"
if [ -d "${JENV_ROOT}" ]; then
  export PATH="${JENV_ROOT}/bin:$PATH"
  eval "$(jenv init -)"
fi

### === SDKMAN ===
# curl -s https://get.sdkman.io | bash

export SDKMAN_DIR="$HOME/.sdkman"
[[ -s "$HOME/.sdkman/bin/sdkman-init.sh" ]] && source "$HOME/.sdkman/bin/sdkman-init.sh"

## NODE / NPM completion scripts

_node_complete() {
  local cur_word options
  cur_word="${COMP_WORDS[COMP_CWORD]}"
  if [[ "${cur_word}" == -* ]] ; then
    COMPREPLY=( $(compgen -W '--track-heap-objects --abort-on-uncaught-exception --napi-modules --redirect-warnings --max-old-space-size --perf-basic-prof --no-warnings --trace-event-file-pattern --check --preserve-symlinks --perf-prof --inspect-port --print --trace-deprecation --inspect-brk --expose_http2 --trace-sync-io --tls-cipher-list --no-force-async-hooks-checks --inspect --eval --loader --pending-deprecation --experimental-worker --expose-http2 --use-bundled-ca --stack-trace-limit --debug-brk --title --experimental-repl-await --debug --no-deprecation --prof-process --throw-deprecation [has_eval_string] --trace-warnings --expose-internals --use-openssl-ca --v8-options --preserve-symlinks-main --interactive --inspect-brk-node --icu-data-dir --require --version --experimental-vm-modules --completion-bash --help --zero-fill-buffers --v8-pool-size [ssl_openssl_cert_store] --security-reverts --experimental-modules --openssl-config --trace-event-categories --debug-port --prof-process --debug= -p -pe -v --inspect-brk= -i --print <arg> --inspect= --debug-brk= -e --inspect-brk-node= -c -h -r --trace-events-enabled' -- "${cur_word}") )
    return 0
  else
    COMPREPLY=( $(compgen -f "${cur_word}") )
    return 0
  fi
}
_node_complete

###-begin-npm-completion-###
#
# npm command completion script
#
# Installation: npm completion >> ~/.bashrc  (or ~/.zshrc)
# Or, maybe: npm completion > /usr/local/etc/bash_completion.d/npm
#

if type complete &>/dev/null; then
  _npm_completion () {
    local words cword
    if type _get_comp_words_by_ref &>/dev/null; then
      _get_comp_words_by_ref -n = -n @ -n : -w words -i cword
    else
      cword="$COMP_CWORD"
      words=("${COMP_WORDS[@]}")
    fi

    local si="$IFS"
    IFS=$'\n' COMPREPLY=($(COMP_CWORD="$cword" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${words[@]}" \
                           2>/dev/null)) || return $?
    IFS="$si"
    if type __ltrim_colon_completions &>/dev/null; then
      __ltrim_colon_completions "${words[cword]}"
    fi
  }
  complete -o default -F _npm_completion npm
elif type compdef &>/dev/null; then
  _npm_completion() {
    local si=$IFS
    compadd -- $(COMP_CWORD=$((CURRENT-1)) \
                 COMP_LINE=$BUFFER \
                 COMP_POINT=0 \
                 npm completion -- "${words[@]}" \
                 2>/dev/null)
    IFS=$si
  }
  compdef _npm_completion npm
elif type compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)) || return $?
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi
###-end-npm-completion-###
_npm_completion

## DOTNET ##

export PATH=$PATH:/usr/local/share/dotnet
